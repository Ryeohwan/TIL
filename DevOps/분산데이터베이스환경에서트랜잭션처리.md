# 1. 2pc

- Two Phase Commit이란 독립적인 머신에서 구동되는 프로세스들의 분산 트랜젝션 보장을 위한 프로토콜이다. 트랜잭션(transaction)이란 용어는 주로 DB에서 많이 다루어지는데, 여러 개의 쿼리 실행을 하나의 작업 단위로 보고 모든 쿼리가 성공하거나, 그 중 하나라도 실패하면 모든 쿼리를 취소하는 작업 단위를 의미한다. 이것을 분산 시스템으로 옮겨 오면 독립적인 머신에서 구동 되는 프로세스들에게 동일한 작업들을 적용함에 있어서 모든 프로세스들에게 적용되거나 반대로 아무 프로세스에게도 적용되지 않는 작업단위를 의미한다.
- 2PC는 트랜잭션을 관리하는 조정자(coordinator)와 트랜잭션의 대상이 되는 참가자(participant)들로 구성된다. 참고로 조정자(coordinator)는 여러 문서들에서 동일한 용어를 사용하는데 참가자(participant)의 경우에는 집단(cohort), 사이트(site) 등등 다양한 용어로 불리고 있으니 다른 문서를 볼 기회가 있다면 참고 하도록 하자.

<br>

    💡 조정자와 참가자 둘이 있다.


## 2pc 알고리즘

서로 다른 서버 S1, S2, S3, ….Sn에서 구동 되고 있는 분산 데이터베이스들이 있다고 가정하자. 각 서버 Si에서는 모든 데이터베이스 작업에 대한 별도의 로그를 관리하며 각 서버 Si와 매칭 되는 로컬 트랜잭션 Ti들, T1, T2, T3, ... Tn이 있다. 각 트랜잭션 Ti들은 서버 Si에 있는 개별 트랜잭션 매니저가 관리하고 있다.

요약하자면 이렇다.

    💡 분산 시스템의 중간에 commit을 관리하는 코디네이터가 있고, 트랜잭션이 필요하면 코디네이터가 모든 참가자에게 현재 커밋이 가능한지 물어 본다. 가능하다면 모두 커밋을 진행하고, 불가능하다면 코디네이터는 모든 참가자들에게 롤백을 요청한다.


## 2pc의 단점

1. 2PC의 주요 단점은 코디네이터에 오류가 발생하면 모든 트랜잭션이 코디네이터가 복구 될 때 까지 지연 된다.
2. <블로킹> 트랜잭션 실행 중 코디네이터에 문제가 생겨 응답을 받지 못하면 참가자 전체가 블로킹에 빠지게 된다. 트랜잭션(T)을 위해 참가자들이 자신의 데이터에 잠금을 걸었지만, 실행중 어떠한 이유로든 코디네이터로 부터 응답을 받지 못하면이 참가자들은 임의로 commit/abort 결정을 할 수 없다. 만일 코디네이터가 정상이고 다른 참가자들은 정상적으로 commit/abort가 결정된 상태에서, 응답을 받지 못한 참가자가 임의로 트랜잭션의 commit/abort를 결정하고 트랜잭션을 종료해버리면 다른 참가자와 다른 결과를 가질 수 있다. 이 때문에 참가자가 코디네이터로 부터 응답을 받지 못하면 코디네이터가 복구되거나 수정될 때까지 최종 결정이 지연 된다.
3.  NoSQL은 이를 지원하지 않기도 한다. 함께 사용하는 DBMS가 동일 제품군이여야 한다는 조건이 있으므로 특정 벤더 제품을 사용해야만 한다. 이는 마이크로서비스 원칙인 느슨한 결합과는 결이 다르다.

# 2. Saga Patterns

- Saga는 서비스 독립적으로 실행할 수 있도록 모델링되어 2PC와 같이 장기간 자원에 Lock을 잡을 필요가 없다는 장점이 있다.
- Saga는 단일 데이터베이스에서 장시간 동작하는 트랜잭션에 대해 서포트하는 메커니즘으로 계획되었지만, 여러 서비스에 걸친 트랜잭션을 관리하는 데에도 적합하다.

## 1. **choreography-based pattern**

choreography-based pattern은 참가자가 중앙 집중식 제어 지점 없이 이벤트를 교환하는 Saga를 조정하는 방법입니다. 각 로컬 트랜잭션은 연출을 사용하여 다른 서비스에서 로컬 트랜잭션을 트리거하는 도메인 이벤트를 게시합니다.

**이점**

- 참가자가 거의 없고 조정 논리가 필요하지 않은 간단한 워크플로에 적합하다.
- 추가 서비스 구현 및 유지 관리가 필요하지 않다.
- 책임은 Saga 참가자에게 분산되므로 단일 실패 지점을 도입하지 않다.

**단점**

- 어떤 Saga 참가자가 어떤 명령을 수신 대기하는지 추적하기 어렵기 때문에 새 단계를 추가할 때 워크플로가 혼동될 수 있다.
- 서로의 명령을 소비해야 하기 때문에 Saga 참가자 간에 순환 종속성이 발생할 위험이 있다.
- 트랜잭션을 시뮬레이션하기 위해 모든 서비스를 실행해야 하므로 통합 테스트는 어렵다.

## 2. **orchestration-based pattern**

오케스트레이션은 중앙 집중식 컨트롤러가 Saga 참가자에게 실행할 로컬 트랜잭션을 알려주는 Saga 조정 방법입니다. Saga 오케스트레이터는 모든 트랜잭션을 처리하고 이벤트에 따라 수행할 작업을 참가자에게 알려줍니다. 오케스트레이터는 Saga 요청을 실행하고, 각 작업의 상태를 저장 및 해석하며, 보상 트랜잭션을 사용하여 오류 복구를 처리합니다.

**이점**

- 시간이 지남에 따라 많은 참가자가 관여하거나 새 참가자가 추가되는 포함된 복잡한 워크플로에 적합하다.
- 프로세스의 모든 참가자를 제어하고 활동 흐름을 제어할 수 있는 경우에 적합하다.
- 오케스트레이터는 일방적으로 Saga 참가자에 의존하기 때문에 순환 종속성을 도입하지 않다.
- Saga 참가자는 다른 참가자의 명령에 대해 알 필요가 없습니다. 문제의 명확한 분리는 비즈니스 논리를 간소화한다.

**단점**

- 추가 디자인 복잡성을 위해서는 조정 논리를 구현해야 한다.
- 오케스트레이터가 전체 워크플로를 관리하기 때문에 추가 실패 지점이 있다.

<br>

## **이 패턴을 사용해야 하는 경우**

다음을 수행해야 하는 경우 Saga 패턴을 사용한다.

- 긴밀한 결합 없이 분산 시스템에서 데이터 일관성을 보장한다.
- 시퀀스의 작업 중 하나가 실패하는 경우 롤백하거나 보상한다.

Saga 패턴은 다음에 덜 적합하다.

- 강력하게 결합된 트랜잭션
- 이전 참가자에서 발생하는 보상 트랜잭션
- 순환 종속성

<br>

### 참고 링크

[마이크로서비스 - 분산 트랜잭션 처리 패턴](https://velog.io/@youngerjesus/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%8C%A8%ED%84%B4-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%B2%98%EB%A6%AC)

[Saga 패턴 - Azure Design Patterns](https://learn.microsoft.com/ko-kr/azure/architecture/reference-architectures/saga/saga)